# -*- coding: utf-8 -*-
"""2DGaussian.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UEsmAkrzTgccH-9oULiiS7c_DxxH0bj4

#  <font color='red'> Review of 2D Gaussian distribution  </font>
"""

import matplotlib.pyplot as plt
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D

import numpy as np
import scipy as sc
from scipy.stats import multivariate_normal
from numpy import linalg as la

"""## Set mean and standard deviation and plot the pdf

"""

# Setting up the grid for plotting
N = 60
X = np.linspace(-6, 6, N)
Y = np.linspace(-6, 6, N)
X, Y = np.meshgrid(X, Y)

pos = np.empty(X.shape + (2,))
pos[:, :, 0] = X
pos[:, :, 1] = Y

# Parameters of the Gaussian

mu = np.array([0, 0]) # Mean
sigma = np.array([[2, 0], [0, 1]]) # Covariance matrix
F = multivariate_normal(mu, sigma)
Z = F.pdf(pos)

# Plotting
fig1 = plt.figure(figsize=[12,6])
ax1 = fig1.add_subplot(1, 2, 1, projection='3d')
ax1.plot_surface(X, Y, Z,cmap=cm.viridis)
ax1.set_xticks([])
ax1.set_yticks([])
ax1.set_zticks([])
ax1.set_title('3D plot')


ax2 = fig1.add_subplot(1, 2, 2)
cs = plt.contour(X,Y,Z)

# Eigen decomposition of Sigma
lam, u = la.eig(sigma)
origin = mu[0], mu[1] # origin point
eig_vec1 = 5*u[:,0]*np.sqrt(lam[0])
eig_vec2 = 5*u[:,1]*np.sqrt(lam[1])
plt.quiver(*origin, *eig_vec1, color=['m'], scale=21)
plt.quiver(*origin, *eig_vec2, color=['r'], scale=21)
ax2.set_title('Contour plot')
ax2.set_aspect('equal')

plt.show()

"""## Draw samples from the distribution and plot

Note that the features are uncorrelated and are equally distributed (variance or spread  is the same in both directions)
"""

# Drawing Nsamples points from the Gaussian distribution
Nsamples = 5000
x, y = np.random.multivariate_normal(mu, sigma, Nsamples).T

# Plotting
fig0 = plt.figure(figsize=[8,8])
ax0 = fig0.add_subplot(1, 1, 1)
s=plt.plot(x, y, 'x')
s=plt.xlabel('x')
s=plt.ylabel('y')
s=plt.axis('equal')
s=ax0.set_title("Figure 1: Uncorrelated features")

"""##  <font color=blue> Gaussian distribution with non-diagonal Covariance matrix </font>

Assume that the features you have come from a Gaussian distribution with non-diagonal Covariance matrix, which implies that  the variables are correlated and hence dependent. The mean is also non zero
"""

# Gaussian parameters
mu1 = np.array([0, 0])
sigma1 = np.array([[1, 1], [1, 3]])

# Gaussian pdf
F1 = multivariate_normal(mu1, sigma1)
Z1 = F1.pdf(pos)

# Plotting the pdf
fig1 = plt.figure(figsize=[8,8])
ax1 = fig1.add_subplot(1, 1, 1, projection='3d')
ax1.plot_surface(X, Y, Z1,cmap=cm.viridis)
ax1.set_xticks([])
ax1.set_yticks([])
ax1.set_zticks([])
ax2.set_title('3D plot')
plt.xlabel('x_1')
plt.ylabel('y_1')

# Contour plot of the pdf
fig2 = plt.figure(figsize=[8,8])
ax2 = fig2.add_subplot(1, 2, 1)
ax2 = fig2.gca();
cs = plt.contour(X,Y,Z1)
ax2.set_title('Contour plot')
ax2.set_aspect('equal')
plt.xlabel('x_1')
plt.ylabel('y_1')

# Drawing 5000 points from the distribution
Nsamples = 5000
x1, y1 = np.random.multivariate_normal(mu1, sigma1, Nsamples).T

# Plotting the features
ax3 = fig2.add_subplot(1, 2, 2)
plt.plot(x1, y1, 'x')
plt.xlim([-6,6])
plt.ylim([-6,6])
plt.xlabel('x_1')
plt.ylabel('y_1')

ax3.set_title('Correlated Samples')
ax3.set_aspect('equal')

ax2 = fig1.add_subplot()
cs = plt.contour(X,Y,Z1)
# Eigen decomposition of Sigma
lam, u = la.eig(sigma1)
origin = mu[0], mu[1] # origin point
eig_vec1 = 5*u[:,0]*np.sqrt(lam[0])
eig_vec2 = 5*u[:,1]*np.sqrt(lam[1])
plt.quiver(*origin, *eig_vec1, color=['m'], scale=21)
plt.quiver(*origin, *eig_vec2, color=['r'], scale=21)
ax2.set_title('Contour plot')
ax2.set_aspect('equal')

plt.show()